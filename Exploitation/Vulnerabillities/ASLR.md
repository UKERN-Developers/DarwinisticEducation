# ASLR
A peak into Address Space Layour Randomization

## About
Address Space Layout Randomization is a technique used today for making it harder for attackers to learn about the address space of a program.

ASLR can be crucial in situations where a vulnerability exists in the system and an attacker wants to make use of it to for example escalate privileges.

ASLR is a random value that is added to the virtual memory initialisation upon the start of the program.

This way the functions of the program are at a different address in the memory each time it is ran.

When an attacker does not know where the functions are at he will not be able to overwrite them to make use of them.

He might still be able to cause a Denial of Service vulnerability (Crash), but he can not go any further.

Though throughout the years many ways of defeating ASLR have been used, some even were side-channel attacks making use of vulnerabilities in the hardware rather than the software.

When an attacker can leak the address of a specific function, he can compare that address with the address of the same program when ASLR is not enabled.

He then knows how many places further the address is in the memory and can add that diference to the offsets of all functions he wants to overwrite making ASLR pointless.

This type of ASLR defeat method is called an Information Leak vulnerability.

In iOS 11.2.6 and below one existed due to a previous mitigation for Spectre having caused another vulnerability, a kernel pointer readable from within userland.


## Defeating KASLR using Information Leaks and offsets
KASLR is ASLR at the kernel level, and has a much larger possible value to slide compared to regular binaries. From the iPhone wiki:
>The kernel image base is randomized by the boot loader (iBoot). This is done by creating random data, doing a SHA-1 hash of it and then using a byte from the SHA-1 hash for the kernel slide. The slide is calculated with this formula: `base=0x01000000+(slide_byte*0x00200000)`

Defeating KASLR with information leaks and offsets is the most common way to defeat it, as it is the most reliable and cheapest way to do it (less power required). Info leaks are acheived in many ways. One such way is through uninitialized pointers. Uninitialized pointers that can be called from userland are very dangerous, as when coding in any C language (C, C++, Obj-C etc) (i think this only applies to C languages is that tru?), pointers will store an address, and across reboots, that address will change to be of that data it was pointing to before. By finding what data it was initially pointing to and the address of it, you can read that pointer and subtract the base address (the one in the kernelcache) to find the KASLR slide of everything. 

Another way is with a incorrect size handling, a buffer overflow of sorts however read only.One of these was in Pegasus for iOS 8.4.1. The info leak for this was in `kOSSerializeNumber` which was a part of `OSUnserializeBinary` which is only called by `OSUnserializeXML`. `OSUnserializeBinary` would only be called if `OSUnserializeXML` detected that the XML file was in binary format. i.e. 
```plist
<dict>
    <string>AAA</string>
    <boolean>1</boolean>
</dict>
```
would be the same as
`0x000000d3 0x81000000 0x09000004 0x00414141 0x8b000001`
`0x000000d3` is the identifier of a binary XML dictionary
`0x81000000` opens `<dict>`
`0x09000004` opens the `<string>`
`0x00414141` is the data inside `<string>` and
`0x8b000001` is the boolean which doesnt require data inside as it is either true or false and that is determined by the last digit
Essentially all `OSUnserializeBinary` would do was iterate through each byte, check what kind of data it was (string, boolean, array etc) and handle each appropriately. However there was a flaw in kOSSerializeNumber:
```C++
case kOSSerializeNumber:
    bufferPos += sizeof(long long);
    if (bufferPos > bufferSize) break;
    value = next[1];
    value <<= 32;
    value |= next[0];
    o = OSNumber::withNumber(value, len);
    next += 2;
    break;
```
The size of OSNumber was not checked and thus by crafting a malicious binary dictionary it was possible to spawn a user client to read back the bytes which would read adjacent bytes. If this confused you, here is what the dictionary would look like:
```XML 
<dict>
    <symbol>AAA</symbol>
    <number size=0x200>0x4141414141414141</number>
</dict>
``````
`<number size=0x200>` is saying that the number is 200 bytes long, however our data is only 2 bytes long. Because there was no check on the actual length of the number, it would return the next 198 bytes to the user client which could be passed back to the malicious application 
## Defeating KASLR using brute-force

## Defeating KASLR with a side-channel attack
